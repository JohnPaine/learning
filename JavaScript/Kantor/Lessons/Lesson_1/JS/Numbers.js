/**
 * Created by John on 28.12.2015.
 */
"use strict"

//var x = prompt("Введите значение", "-11.5");

// Пустая строка и строка из пробельных символов преобразуются к 0, поэтому считаются числами.
//if (isNaN(x)) {
//    alert( "Строка преобразовалась в NaN. Не число" );
//} else {
//    alert( "Число" );
//}

// Если же нужна действительно точная проверка на число,
// которая не считает числом строку из пробелов, логические и специальные значения,
// а также отсекает Infinity — используйте следующую функцию isNumeric:
//function isNumeric(n) {
//    return !isNaN(parseFloat(n)) && isFinite(n);
//}
//
//if (!isNumeric(x)) {
//    alert( "Строка преобразовалась в NaN. Не число" );
//} else {
//    alert( "Число" );
//}


// Округление
//alert( Math.floor(3.1) );  // 3
//alert( Math.ceil(3.1) );   // 4
//alert( Math.round(3.1) );  // 3

// Битовые операторы делают любое число 32-битным целым, обрезая десятичную часть.
// В результате побитовая операция, которая не изменяет число, например, двойное битовое НЕ — округляет его:
//alert( ~~12.3 ); // 12
//alert( 12.3 ^ 0 ); // 12
//alert( 1.2 + 1.3 ^ 0 ); // 2, приоритет ^ меньше, чем +
//var x = a * b / c ^ 0; // читается как "a * b / c и округлить"

// Для округления до нужной цифры после запятой можно умножить и поделить на 10 с нужным количеством нулей.
// Например, округлим 3.456 до 2го знака после запятой:
//var n = 3.456;
//alert( Math.round(n * 100) / 100 ); // 3.456 -> 345.6 -> 346 -> 3.46

// Существует также специальный метод num.toFixed(precision),
// который округляет число num до точности precision и возвращает результат в виде строки:
//n = 12.34;
//alert( n.toFixed(1) ); // "12.3"

// Итоговая строка, при необходимости, дополняется нулями до нужной точности:
//n = 12.34;
//alert( n.toFixed(5) ); // "12.34000", добавлены нули до 5 знаков после запятой

// Если нам нужно именно число, то мы можем получить его, применив '+' к результату n.toFixed(..):
//n = 12.34;
//alert( +n.toFixed(5) ); // 12.34


//  Метод toFixed не эквивалентен Math.round!
//var price = 6.35;
//alert( price.toFixed(1) ); // 6.3
//alert( Math.round(price * 10) / 10 ); // 6.4
// Как видно, результат разный! Вариант округления через Math.round получился более корректным,
// так как по общепринятым правилам 5 округляется вверх. А toFixed может округлить его как вверх, так и вниз.



// НЕТОЧНЫЕ ВЫЧИСЛЕНИЯ
//alert( 0.1 + 0.2 );

// Число 0.1 (одна десятая) записывается просто в десятичном формате.
// Но в двоичной системе счисления это бесконечная дробь,
// так как единица на десять в двоичной системе так просто не делится.
// Также бесконечной дробью является 0.2 (=2/10).

// Двоичное значение бесконечных дробей хранится только до определенного знака,
// поэтому возникает неточность. Её даже можно увидеть:
alert( 0.1.toFixed(20) ); // 0.10000000000000000555

// Решение
// 1. Сделать их целыми, сложить, а потом поделить:
alert( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3
// Это работает, т.к. числа 0.1*10 = 1 и 0.2*10 = 2 могут быть точно представлены в двоичной системе.

// 2. Сложить, а затем округлить до разумного знака после запятой.
// Округления до 10-го знака обычно бывает достаточно, чтобы отсечь ошибку вычислений:
var result = 0.1 + 0.2;
alert( +result.toFixed(10) ); // 0.3


// Из 64 бит, отведённых на число, сами цифры числа занимают до 52 бит,
// остальные 11 бит хранят позицию десятичной точки и один бит — знак.
// Так что если 52 бит не хватает на цифры, то при записи пропадут младшие разряды.
alert( 9999999999999999 ); // выведет 10000000000000000

// Ради справедливости заметим, что в точности то же самое происходит в любом другом языке,
// где используется формат IEEE 754, включая Java, C, PHP, Ruby, Perl.


// Formating
var number = 123456789;
alert( number.toLocaleString() ); // 123 456 789

/// FROM WORK
/**
 * Created by shtefan on 28.12.2015.
 */
//alert( 12.34.toFixed(1) ); // 12.3
//alert(12.toFixed(1)); // ошибка!
//alert( 12..toFixed(1) ); // 12.0
//alert( 3e-5 ); // 0.00003  <-- 5 нулей, включая начальный ноль
//alert( 1 / 0 ); // Infinity
//alert( 12345 / 0 ); // Infinity
//alert( Infinity > 1234567890 ); // true
//alert( Infinity + 5 == Infinity ); // true
//alert( 1e500 ); // Infinity
//alert( 0 / 0 ); // NaN


//var n = 0 / 0;
//alert( isNaN(n) ); // true
//alert( isNaN("12") ); // false, строка преобразовалась к обычному числу 12
// Забавный способ проверки на NaN
//if (n !== n)
//    alert( 'n = NaN!' );

//alert( isFinite(1) ); // true
//alert( isFinite(Infinity) ); // false
//alert( isFinite(NaN) ); // false

//alert( +"  -12" ); // -12
//alert( +" \n34  \n" ); // 34, перевод строки \n является пробельным символом
//alert( +"" ); // 0, пустая строка становится нулем
//alert( +"1 2" ); // NaN, пробел посередине числа - ошибка
//alert( '12.34' / "-2" ); // -6.17

//alert( parseInt('12px') ); // 12

// При возникновении ошибки возвращается число, которое получилось.
// Функция parseInt читает из строки целое число, а parseFloat — дробное.
//alert( parseInt('12px') ); // 12, ошибка на символе 'p'
//alert( parseFloat('12.3.4') ) ;// 12.3, ошибка на второй точке
//alert( parseInt('a123') ); // NaN
//alert( parseInt('FF', 16) ); // 255










